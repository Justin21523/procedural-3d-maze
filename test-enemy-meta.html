<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Model Meta Preview</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0f1115;
      --panel: rgba(20, 24, 32, 0.92);
      --border: rgba(255, 255, 255, 0.12);
      --text: rgba(255, 255, 255, 0.92);
      --muted: rgba(255, 255, 255, 0.65);
      --accent: #7aa2ff;
      --good: #2ecc71;
      --bad: #ff5a5a;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }

    #app {
      position: fixed;
      inset: 0;
      display: grid;
      grid-template-columns: 420px 1fr;
    }

    #panel {
      padding: 14px 14px 18px;
      border-right: 1px solid var(--border);
      background: var(--panel);
      overflow: auto;
    }

    #panel h1 {
      margin: 0 0 10px;
      font-size: 16px;
      font-weight: 650;
      letter-spacing: 0.2px;
    }

    #panel p {
      margin: 6px 0 10px;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }

    .row {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
      margin: 10px 0;
    }

    label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 6px;
    }

    select, input[type="number"], textarea {
      width: 100%;
      background: rgba(0, 0, 0, 0.2);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 9px 10px;
      font-size: 13px;
      outline: none;
    }

    input[type="range"] {
      width: 100%;
    }

    textarea {
      min-height: 170px;
      resize: vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      line-height: 1.35;
    }

    button {
      background: rgba(122, 162, 255, 0.15);
      border: 1px solid rgba(122, 162, 255, 0.35);
      color: var(--text);
      padding: 9px 12px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 13px;
    }

    button:hover {
      background: rgba(122, 162, 255, 0.22);
    }

    .pill {
      display: inline-block;
      padding: 2px 8px;
      border: 1px solid var(--border);
      border-radius: 999px;
      font-size: 12px;
      color: var(--muted);
    }

    .status-ok { color: var(--good); }
    .status-bad { color: var(--bad); }

    #canvas {
      position: relative;
    }

    #viewport {
      width: 100%;
      height: 100%;
      display: block;
    }

    #hud {
      position: absolute;
      left: 10px;
      bottom: 10px;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(0, 0, 0, 0.35);
      font-size: 12px;
      color: var(--muted);
      pointer-events: none;
      max-width: 70%;
      line-height: 1.35;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="panel">
      <h1>Model Meta Preview</h1>
      <p>
        Enemy: edits <span class="pill">scaleMultiplier</span>/<span class="pill">groundOffset</span>/<span class="pill">correctionRotationDeg</span> (saved into enemy <span class="pill">manifest.json</span>).
        Weapon: edits <span class="pill">view.offset</span>/<span class="pill">view.rotationDeg</span>/<span class="pill">view.scale</span> (saved into <span class="pill">/models/weapon/meta.json</span>).
      </p>

      <div class="row">
        <div>
          <label for="assetSelect">Asset Type</label>
          <select id="assetSelect">
            <option value="enemy">Enemy</option>
            <option value="weapon">Weapon</option>
          </select>
        </div>
        <div style="text-align:right;">
          <button id="saveBtn" type="button">Save meta.json</button>
        </div>
      </div>

      <div class="row">
        <div>
          <label for="modelSelect">Model</label>
          <select id="modelSelect"></select>
        </div>
        <div style="text-align:right;">
          <div class="pill" id="metaFileHint">meta.json: (n/a)</div>
        </div>
      </div>

      <div id="enemyControls">
      <div class="row">
        <div>
          <label for="typeSelect">Monster Type (base stats.scale)</label>
          <select id="typeSelect"></select>
        </div>
        <div style="text-align:right;">
          <div class="pill" id="modelInfo">height: –</div>
        </div>
      </div>

      <div class="row">
        <div>
          <label for="scaleMul">scaleMultiplier <span id="scaleMulVal" class="pill">1.00</span></label>
          <input id="scaleMul" type="range" min="0.01" max="200.00" step="0.05" value="1.00">
        </div>
        <div style="width:110px;">
          <label for="scaleMulNum">Value</label>
          <input id="scaleMulNum" type="number" step="0.05" value="1.00">
        </div>
      </div>

      <div class="row">
        <div>
          <label for="groundOffset">groundOffset <span id="groundOffsetVal" class="pill">0.02</span></label>
          <input id="groundOffset" type="range" min="-1.00" max="1.00" step="0.01" value="0.02">
        </div>
        <div style="width:110px;">
          <label for="groundOffsetNum">Value</label>
          <input id="groundOffsetNum" type="number" step="0.01" value="0.02">
        </div>
      </div>

      <div class="row">
        <div>
          <label>correctionRotationDeg (X / Y / Z)</label>
          <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;">
            <input id="rotX" type="number" min="-180" max="180" step="1" value="0">
            <input id="rotY" type="number" min="-180" max="180" step="1" value="0">
            <input id="rotZ" type="number" min="-180" max="180" step="1" value="0">
          </div>
        </div>
        <div style="text-align:right;">
          <button id="reloadMetaBtn" type="button">Reload meta.json</button>
        </div>
      </div>

      <div class="row">
        <div>
          <label for="jsonOut">meta.json (paste into folder)</label>
          <textarea id="jsonOut" readonly spellcheck="false"></textarea>
        </div>
      </div>
      </div>

      <div id="weaponControls" style="display:none;">
      <div class="row">
        <div>
          <label>Weapon Gizmo</label>
          <div style="display:flex; gap:8px; flex-wrap:wrap;">
            <button id="weaponGizmoMove" type="button">Move</button>
            <button id="weaponGizmoRotate" type="button">Rotate</button>
            <button id="weaponGizmoOff" type="button">Off</button>
            <button id="weaponReset" type="button" style="background: rgba(255, 180, 122, 0.15); border-color: rgba(255, 180, 122, 0.35);">Reset</button>
          </div>
        </div>
        <div style="text-align:right;">
          <div class="pill">W/E/R: Move/Rotate/Scale</div>
        </div>
      </div>

      <div class="row">
        <div>
          <label>view.offset (X / Y / Z)</label>
          <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;">
            <input id="wOffX" type="number" step="0.01" value="0">
            <input id="wOffY" type="number" step="0.01" value="0">
            <input id="wOffZ" type="number" step="0.01" value="0">
          </div>
        </div>
        <div style="text-align:right;">
          <div class="pill" id="weaponInfo">bbox: –</div>
        </div>
      </div>

      <div class="row">
        <div>
          <label>view.rotationDeg (X / Y / Z)</label>
          <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;">
            <input id="wRotX" type="number" min="-180" max="180" step="1" value="0">
            <input id="wRotY" type="number" min="-180" max="180" step="1" value="0">
            <input id="wRotZ" type="number" min="-180" max="180" step="1" value="0">
          </div>
        </div>
      </div>

      <div class="row">
        <div>
          <label for="wScale">view.scale <span id="wScaleVal" class="pill">1.00</span></label>
          <input id="wScale" type="range" min="0.01" max="200.00" step="0.05" value="1.00">
        </div>
        <div style="width:110px;">
          <label for="wScaleNum">Value</label>
          <input id="wScaleNum" type="number" step="0.05" value="1.00">
        </div>
      </div>

      <div class="row">
        <div>
          <label for="jsonOutWeapon">weapon meta entry</label>
          <textarea id="jsonOutWeapon" readonly spellcheck="false"></textarea>
        </div>
      </div>
      </div>

      <div class="row">
        <button id="copyBtn" type="button">Copy JSON</button>
        <div id="status" class="pill">(idle)</div>
      </div>
    </div>

    <div id="canvas">
      <canvas id="viewport"></canvas>
      <div id="hud"></div>
    </div>
  </div>

  <script type="module" src="/src/ui/toolNav.js"></script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    import { TransformControls } from 'three/examples/jsm/controls/TransformControls.js';

    import { ModelLoader } from '/src/entities/modelLoader.js';
    import { Monster } from '/src/entities/monster.js';
    import { MonsterTypes } from '/src/ai/monsterTypes.js';
    import { applyEnemyMetaToTypeConfig, applyEnemyModelMeta, getCandidateMetaUrls } from '/src/ai/enemyCatalog.js';
    import { WeaponView } from '/src/player/weaponView.js';
    import { CONFIG } from '/src/core/config.js';

    const ui = {
      assetSelect: document.getElementById('assetSelect'),
      saveBtn: document.getElementById('saveBtn'),
      modelSelect: document.getElementById('modelSelect'),
      typeSelect: document.getElementById('typeSelect'),
      metaFileHint: document.getElementById('metaFileHint'),
      modelInfo: document.getElementById('modelInfo'),
      scaleMul: document.getElementById('scaleMul'),
      scaleMulNum: document.getElementById('scaleMulNum'),
      scaleMulVal: document.getElementById('scaleMulVal'),
      groundOffset: document.getElementById('groundOffset'),
      groundOffsetNum: document.getElementById('groundOffsetNum'),
      groundOffsetVal: document.getElementById('groundOffsetVal'),
      rotX: document.getElementById('rotX'),
      rotY: document.getElementById('rotY'),
      rotZ: document.getElementById('rotZ'),
      jsonOut: document.getElementById('jsonOut'),
      jsonOutWeapon: document.getElementById('jsonOutWeapon'),
      reloadMetaBtn: document.getElementById('reloadMetaBtn'),
      copyBtn: document.getElementById('copyBtn'),
      status: document.getElementById('status'),
      hud: document.getElementById('hud'),
      canvas: document.getElementById('viewport'),
      enemyControls: document.getElementById('enemyControls'),
      weaponControls: document.getElementById('weaponControls'),
      weaponInfo: document.getElementById('weaponInfo'),
      wOffX: document.getElementById('wOffX'),
      wOffY: document.getElementById('wOffY'),
      wOffZ: document.getElementById('wOffZ'),
      wRotX: document.getElementById('wRotX'),
      wRotY: document.getElementById('wRotY'),
      wRotZ: document.getElementById('wRotZ'),
      wScale: document.getElementById('wScale'),
      wScaleNum: document.getElementById('wScaleNum'),
      wScaleVal: document.getElementById('wScaleVal')
    };

    const DEG2RAD = Math.PI / 180;

    function setStatus(text, ok = true) {
      ui.status.textContent = text;
      ui.status.classList.toggle('status-ok', ok);
      ui.status.classList.toggle('status-bad', !ok);
    }

    function clamp(n, min, max) {
      if (!Number.isFinite(n)) return n;
      return Math.max(min, Math.min(max, n));
    }

    function toNum(value, fallback) {
      const n = Number(value);
      return Number.isFinite(n) ? n : fallback;
    }

    function format(n, digits = 2) {
      return Number.isFinite(n) ? n.toFixed(digits) : String(n);
    }

    function deepClone(obj) {
      return obj ? JSON.parse(JSON.stringify(obj)) : obj;
    }

    function getAssetType() {
      return ui.assetSelect?.value === 'weapon' ? 'weapon' : 'enemy';
    }

    function buildEnemyMetaFromUI(baseMeta) {
      const scaleMultiplier = clamp(toNum(ui.scaleMulNum.value, 1), 0.0001, 1_000_000);
      const groundOffset = clamp(toNum(ui.groundOffsetNum.value, 0.02), -1_000_000, 1_000_000);
      const correctionRotationDeg = {
        x: clamp(toNum(ui.rotX.value, 0), -180, 180),
        y: clamp(toNum(ui.rotY.value, 0), -180, 180),
        z: clamp(toNum(ui.rotZ.value, 0), -180, 180)
      };

      const next = { ...(baseMeta || {}) };
      next.scaleMultiplier = scaleMultiplier;
      next.groundOffset = groundOffset;
      next.correctionRotationDeg = correctionRotationDeg;
      delete next.correctionRotationRad;

      return next;
    }

    function buildEnemyMetaForRuntime(metaJson) {
      const deg = metaJson?.correctionRotationDeg || { x: 0, y: 0, z: 0 };
      return {
        correctionRotationRad: {
          x: (Number(deg.x) || 0) * DEG2RAD,
          y: (Number(deg.y) || 0) * DEG2RAD,
          z: (Number(deg.z) || 0) * DEG2RAD
        }
      };
    }

    function buildWeaponMetaFromUI(baseMeta) {
      void baseMeta;
      const offset = {
        x: clamp(toNum(ui.wOffX.value, 0), -1_000_000, 1_000_000),
        y: clamp(toNum(ui.wOffY.value, 0), -1_000_000, 1_000_000),
        z: clamp(toNum(ui.wOffZ.value, 0), -1_000_000, 1_000_000)
      };
      const rotationDeg = {
        x: clamp(toNum(ui.wRotX.value, 0), -180, 180),
        y: clamp(toNum(ui.wRotY.value, 0), -180, 180),
        z: clamp(toNum(ui.wRotZ.value, 0), -180, 180)
      };
      const scale = clamp(toNum(ui.wScaleNum.value, 1), 0.0001, 1_000_000);
      return {
        view: {
          offset,
          rotationDeg,
          scale
        }
      };
    }

    function buildWeaponViewForRuntime(metaJson) {
      const view = metaJson?.view && typeof metaJson.view === 'object' ? metaJson.view : {};
      const off = view?.offset && typeof view.offset === 'object' ? view.offset : { x: 0, y: 0, z: 0 };
      const deg = view?.rotationDeg && typeof view.rotationDeg === 'object' ? view.rotationDeg : { x: 0, y: 0, z: 0 };
      return {
        offset: {
          x: toNum(off.x, 0),
          y: toNum(off.y, 0),
          z: toNum(off.z, 0)
        },
        rotation: {
          x: toNum(deg.x, 0) * DEG2RAD,
          y: toNum(deg.y, 0) * DEG2RAD,
          z: toNum(deg.z, 0) * DEG2RAD
        },
        scale: toNum(view.scale, 1.0)
      };
    }

    function getSelectedModelPath() {
      return ui.modelSelect.value || null;
    }

    function getSelectedMonsterTypeKey() {
      return ui.typeSelect.value || 'HUNTER';
    }

    function updateSliderDisplays() {
      ui.scaleMulVal.textContent = format(toNum(ui.scaleMulNum.value, 1), 2);
      ui.groundOffsetVal.textContent = format(toNum(ui.groundOffsetNum.value, 0.02), 2);
      ui.wScaleVal.textContent = format(toNum(ui.wScaleNum.value, 1), 2);
    }

    function syncRangeToNumber(rangeEl, numberEl) {
      numberEl.value = rangeEl.value;
      updateSliderDisplays();
    }

    function syncNumberToRange(numberEl, rangeEl) {
      rangeEl.value = numberEl.value;
      updateSliderDisplays();
    }

    async function fetchManifest(assetType) {
      const type = assetType === 'weapon' ? 'weapon' : 'enemy';
      const urls = type === 'weapon'
        ? ['/models/weapon/manifest.json', '/models/manifest.json']
        : ['/models/enemy/manifest.json', '/models/manifest.json'];
      for (const url of urls) {
        try {
          const res = await fetch(url, { cache: 'no-store' });
          if (!res.ok) continue;
          const json = await res.json();
          const models = url.endsWith('/models/manifest.json')
            ? (type === 'weapon' ? json?.weaponModels : json?.enemyModels)
            : (Array.isArray(json) ? json : json?.models);
          const list = Array.isArray(models) ? models.filter(p => typeof p === 'string') : [];
          return list;
        } catch (err) {
          void err;
        }
      }
      return [];
    }

    async function fetchExistingEnemyMeta(modelPath) {
      const urls = getCandidateMetaUrls(modelPath);
      for (const url of urls) {
        try {
          const res = await fetch(url, { cache: 'no-store' });
          if (!res.ok) continue;
          const json = await res.json();
          return { url, json };
        } catch (err) {
          void err;
        }
      }
      return { url: urls[0] || null, json: null };
    }

    async function fetchWeaponMetaFile() {
      try {
        const res = await fetch('/models/weapon/meta.json', { cache: 'no-store' });
        if (!res.ok) return { schemaVersion: 1, weapons: {} };
        const json = await res.json();
        if (!json || typeof json !== 'object' || Array.isArray(json)) return { schemaVersion: 1, weapons: {} };
        const weapons = json.weapons && typeof json.weapons === 'object' ? json.weapons : {};
        return { ...json, schemaVersion: 1, weapons };
      } catch (err) {
        void err;
        return { schemaVersion: 1, weapons: {} };
      }
    }

    function applyEnemyMetaToUI(metaJson) {
      const scaleMultiplier = toNum(metaJson?.scaleMultiplier, 1);
      const groundOffset = toNum(metaJson?.groundOffset, 0.02);

      const deg =
        metaJson?.correctionRotationDeg ||
        metaJson?.correctionRotationRad
          ? {
            x: toNum(metaJson?.correctionRotationDeg?.x, (toNum(metaJson?.correctionRotationRad?.x, 0) / DEG2RAD)),
            y: toNum(metaJson?.correctionRotationDeg?.y, (toNum(metaJson?.correctionRotationRad?.y, 0) / DEG2RAD)),
            z: toNum(metaJson?.correctionRotationDeg?.z, (toNum(metaJson?.correctionRotationRad?.z, 0) / DEG2RAD))
          }
          : { x: 0, y: 0, z: 0 };

      ui.scaleMul.value = String(scaleMultiplier);
      ui.scaleMulNum.value = String(scaleMultiplier);
      ui.groundOffset.value = String(groundOffset);
      ui.groundOffsetNum.value = String(groundOffset);

      ui.rotX.value = String(Math.round(deg.x));
      ui.rotY.value = String(Math.round(deg.y));
      ui.rotZ.value = String(Math.round(deg.z));

      updateSliderDisplays();
    }

    function applyWeaponMetaToUI(metaJson) {
      const view = metaJson?.view && typeof metaJson.view === 'object' ? metaJson.view : {};
      const off = view?.offset && typeof view.offset === 'object' ? view.offset : { x: 0, y: 0, z: 0 };
      const rotDeg = view?.rotationDeg && typeof view.rotationDeg === 'object'
        ? view.rotationDeg
        : view?.rotationRad && typeof view.rotationRad === 'object'
          ? {
            x: toNum(view.rotationRad.x, 0) / DEG2RAD,
            y: toNum(view.rotationRad.y, 0) / DEG2RAD,
            z: toNum(view.rotationRad.z, 0) / DEG2RAD
          }
          : view?.rotation && typeof view.rotation === 'object'
            ? {
              x: toNum(view.rotation.x, 0) / DEG2RAD,
              y: toNum(view.rotation.y, 0) / DEG2RAD,
              z: toNum(view.rotation.z, 0) / DEG2RAD
            }
            : { x: 0, y: 0, z: 0 };

      ui.wOffX.value = String(toNum(off.x, 0));
      ui.wOffY.value = String(toNum(off.y, 0));
      ui.wOffZ.value = String(toNum(off.z, 0));
      ui.wRotX.value = String(Math.round(toNum(rotDeg.x, 0)));
      ui.wRotY.value = String(Math.round(toNum(rotDeg.y, 0)));
      ui.wRotZ.value = String(Math.round(toNum(rotDeg.z, 0)));

      const scale = toNum(view.scale, 1);
      ui.wScale.value = String(scale);
      ui.wScaleNum.value = String(scale);
      updateSliderDisplays();
    }

    // Three.js scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0e14);

    const camera = new THREE.PerspectiveCamera(60, 1, 0.01, 1000);
    camera.position.set(3.5, 2.4, 3.5);
    scene.add(camera);

    const renderer = new THREE.WebGLRenderer({ canvas: ui.canvas, antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.shadowMap.enabled = true;

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0, 1.0, 0);
    controls.enablePan = true;

    scene.add(new THREE.AmbientLight(0xffffff, 0.55));
    const sun = new THREE.DirectionalLight(0xffffff, 0.9);
    sun.position.set(6, 10, 7);
    sun.castShadow = true;
    sun.shadow.mapSize.set(1024, 1024);
    scene.add(sun);

    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(40, 40),
      new THREE.MeshStandardMaterial({ color: 0x121826, roughness: 1, metalness: 0 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);
    const gridHelper = new THREE.GridHelper(40, 40, 0x2a3246, 0x1e2638);
    scene.add(gridHelper);
    const axesHelper = new THREE.AxesHelper(1.2);
    scene.add(axesHelper);

    const loader = new ModelLoader();
    let currentModel = null;
    let currentHelper = null;
    let baseMeta = null;
    let lastMetaUrl = null;
    let weaponMetaFile = null;
    let loadToken = 0;
    let reloadTimer = null;
    let weaponView = null;
    let transformControls = null;
    let weaponPreviewRoot = null;
    let weaponTransformNode = null;

    function clearCurrentModel() {
      if (currentHelper) scene.remove(currentHelper);
      currentHelper = null;
      if (currentModel) scene.remove(currentModel);
      currentModel = null;
      if (weaponPreviewRoot) {
        scene.remove(weaponPreviewRoot);
        weaponPreviewRoot = null;
      }
      weaponTransformNode = null;
      if (transformControls) {
        transformControls.detach();
        transformControls.visible = false;
      }
    }

    function setMetaHint(modelPath, metaUrl) {
      if (!modelPath) {
        ui.metaFileHint.textContent = 'meta.json: (n/a)';
        return;
      }
      ui.metaFileHint.textContent = metaUrl ? `meta.json: ${metaUrl}` : 'meta.json: (missing)';
    }

    function updateJsonOutput() {
      const modelPath = getSelectedModelPath();
      if (getAssetType() === 'weapon') {
        const entry = buildWeaponMetaFromUI(baseMeta);
        ui.jsonOutWeapon.value = JSON.stringify({ [modelPath || '']: entry }, null, 2);
        ui.jsonOut.value = '';
      } else {
        const meta = buildEnemyMetaFromUI(baseMeta);
        ui.jsonOut.value = JSON.stringify(meta, null, 2);
        ui.jsonOutWeapon.value = '';
      }
    }

    async function postMeta(modelPath, meta) {
      const res = await fetch('/api/model-meta', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ modelPath, meta })
      });
      const json = await res.json().catch(() => null);
      if (!res.ok || !json?.ok) {
        throw new Error(json?.error || `HTTP ${res.status}`);
      }
      return json;
    }

    let autoSaveTimer = null;
    function notifyMetaUpdated(kind, modelPath) {
      try {
        if (typeof BroadcastChannel === 'undefined') return;
        const ch = new BroadcastChannel('p3dm-meta');
        ch.postMessage({ kind, modelPath, at: Date.now() });
        ch.close();
      } catch (err) {
        void err;
      }
    }

    function scheduleAutoSave() {
      if (autoSaveTimer) clearTimeout(autoSaveTimer);
      autoSaveTimer = setTimeout(() => {
        void saveMetaForSelectedModel({ silent: true });
      }, 500);
    }

    async function saveMetaForSelectedModel(options = {}) {
      const modelPath = getSelectedModelPath();
      if (!modelPath) return;

      const silent = options?.silent === true;
      if (!silent) setStatus('Saving…');
      try {
        if (getAssetType() === 'weapon') {
          const entry = buildWeaponMetaFromUI(baseMeta);
          const file = weaponMetaFile || await fetchWeaponMetaFile();
          const next = {
            schemaVersion: 1,
            ...(file && typeof file === 'object' ? file : {}),
            weapons: {
              ...(file?.weapons && typeof file.weapons === 'object' ? file.weapons : {})
            }
          };
          next.weapons[modelPath] = entry;
          const saved = await postMeta(modelPath, next);
          weaponMetaFile = next;
          lastMetaUrl = saved?.metaUrl || '/models/weapon/meta.json';
          setMetaHint(modelPath, lastMetaUrl);
          notifyMetaUpdated('weapon', modelPath);
        } else {
          const meta = buildEnemyMetaFromUI(baseMeta);
          const saved = await postMeta(modelPath, meta);
          lastMetaUrl = saved?.metaUrl || lastMetaUrl;
          setMetaHint(modelPath, lastMetaUrl);
          notifyMetaUpdated('enemy', modelPath);
        }

        if (!silent) setStatus('Saved', true);
      } catch (err) {
        console.error(err);
        if (!silent) setStatus(`Save failed: ${err?.message || err}`, false);
      }
    }

    function setAssetUiMode(type) {
      const isWeapon = type === 'weapon';
      ui.enemyControls.style.display = isWeapon ? 'none' : 'block';
      ui.weaponControls.style.display = isWeapon ? 'block' : 'none';
      controls.enabled = true;
      ground.visible = true;
      gridHelper.visible = true;
      axesHelper.visible = true;
      ui.copyBtn.textContent = isWeapon ? 'Copy Entry JSON' : 'Copy JSON';
      ui.weaponInfo.textContent = 'bbox: –';
      ui.modelInfo.textContent = 'height: –';
      if (weaponView?.setEnabled) weaponView.setEnabled(false);
    }

    function ensureWeaponView() {
      if (weaponView) return weaponView;
      const cameraController = {
        getCamera: () => camera,
        getYaw: () => 0,
        getPitch: () => 0
      };
      const playerRef = { position: new THREE.Vector3() };
      weaponView = new WeaponView(scene, cameraController, playerRef);
      weaponView.setEnabled(false);
      return weaponView;
    }

    function ensureTransformControls() {
      if (transformControls) return transformControls;
      transformControls = new TransformControls(camera, renderer.domElement);
      transformControls.enabled = true;
      transformControls.visible = false;
      transformControls.setMode('translate');
      transformControls.addEventListener('dragging-changed', (e) => {
        controls.enabled = !e.value;
      });
      transformControls.addEventListener('objectChange', () => {
        if (getAssetType() !== 'weapon') return;
        const obj = transformControls.object;
        if (!obj) return;
        ui.wOffX.value = String(obj.position.x.toFixed(3));
        ui.wOffY.value = String(obj.position.y.toFixed(3));
        ui.wOffZ.value = String(obj.position.z.toFixed(3));
        ui.wRotX.value = String(Math.round(THREE.MathUtils.radToDeg(obj.rotation.x)));
        ui.wRotY.value = String(Math.round(THREE.MathUtils.radToDeg(obj.rotation.y)));
        ui.wRotZ.value = String(Math.round(THREE.MathUtils.radToDeg(obj.rotation.z)));
        ui.wScale.value = String(obj.scale.x.toFixed(3));
        ui.wScaleNum.value = String(obj.scale.x.toFixed(3));
        updateJsonOutput();
        scheduleAutoSave();
      });
      scene.add(transformControls);
      return transformControls;
    }

    function applyWeaponUiToObject(obj) {
      obj.position.set(
        toNum(ui.wOffX.value, 0),
        toNum(ui.wOffY.value, 0),
        toNum(ui.wOffZ.value, 0)
      );
      obj.rotation.set(
        toNum(ui.wRotX.value, 0) * DEG2RAD,
        toNum(ui.wRotY.value, 0) * DEG2RAD,
        toNum(ui.wRotZ.value, 0) * DEG2RAD
      );
      const s = toNum(ui.wScaleNum.value, 1);
      obj.scale.setScalar(Math.max(0.0001, s));
    }

    async function loadAndPreview() {
      const token = ++loadToken;
      const modelPath = getSelectedModelPath();
      if (!modelPath) return;

      clearCurrentModel();
      setStatus('Loading model…');
      updateJsonOutput();

      try {
        const assetType = getAssetType();
        setAssetUiMode(assetType);

        if (assetType === 'weapon') {
          const metaJson = buildWeaponMetaFromUI(baseMeta);
          const viewRuntime = buildWeaponViewForRuntime(metaJson);
          const view = ensureWeaponView();

          // Build a world-space preview root using WeaponView's prepared model loader.
          const obj = await view.loadModelObject(modelPath);
          if (token !== loadToken) return;

          if (!obj) throw new Error('Weapon model failed to load');

          weaponPreviewRoot = new THREE.Group();
          weaponPreviewRoot.name = '__weaponPreviewRoot';
          weaponTransformNode = new THREE.Group();
          weaponTransformNode.name = '__weaponTransform';
          weaponTransformNode.add(obj);
          weaponPreviewRoot.add(weaponTransformNode);
          scene.add(weaponPreviewRoot);

          // Apply view transform on a wrapper node so the model's internal normalization stays intact.
          weaponTransformNode.position.set(viewRuntime.offset.x, viewRuntime.offset.y, viewRuntime.offset.z);
          weaponTransformNode.rotation.set(viewRuntime.rotation.x, viewRuntime.rotation.y, viewRuntime.rotation.z);
          weaponTransformNode.scale.setScalar(Math.max(0.0001, viewRuntime.scale));

          // Attach gizmo to the weapon object for interactive tweaking.
          const gizmo = ensureTransformControls();
          gizmo.attach(weaponTransformNode);
          gizmo.visible = true;

          // Frame the camera so the weapon is visible, but keep it close to "first-person" scale.
          controls.target.set(0, 0, -0.7);
          camera.position.set(0.2, 0.05, 0.55);
          camera.lookAt(controls.target);

          const box = new THREE.Box3().setFromObject(weaponTransformNode);
          const size = new THREE.Vector3();
          box.getSize(size);
          ui.weaponInfo.textContent = `bbox: ${format(size.x, 2)}×${format(size.y, 2)}×${format(size.z, 2)}`;

          ui.hud.textContent =
            `Weapon: ${modelPath}\n` +
            `meta: /models/weapon/meta.json\n` +
            `Tip: adjust view.offset / rotationDeg / scale.`;

          setStatus('Ready', true);
          return;
        }

        const selectedTypeKey = getSelectedMonsterTypeKey();
        const typeConfig = deepClone(MonsterTypes[selectedTypeKey] || MonsterTypes.HUNTER || {});

        const metaJson = buildEnemyMetaFromUI(baseMeta);
        const runtimeMeta = buildEnemyMetaForRuntime(metaJson);

        const model = await loader.loadModel(modelPath);
        if (token !== loadToken) return;

        applyEnemyModelMeta(model, runtimeMeta);
        applyEnemyMetaToTypeConfig(typeConfig, metaJson);

        const previewMonster = new Monster(model, { x: 0, y: 0 }, null, typeConfig, null);
        const m = previewMonster.getModel();
        m.position.x = 0;
        m.position.z = 0;

        m.traverse((child) => {
          if (!child?.isMesh) return;
          child.castShadow = true;
          child.receiveShadow = true;
        });

        scene.add(m);
        currentModel = m;
        currentHelper = new THREE.BoxHelper(m, 0x7aa2ff);
        scene.add(currentHelper);

        const box = new THREE.Box3().setFromObject(m);
        const size = new THREE.Vector3();
        box.getSize(size);
        ui.modelInfo.textContent = `height: ${format(size.y, 2)}`;

        ui.hud.textContent =
          `Model: ${modelPath}\n` +
          `meta: ${lastMetaUrl || '(none)'}\n` +
          `Height: ${format(size.y, 2)} (target ≈ ${(CONFIG.MONSTER_BASE_HEIGHT ?? 1.8).toFixed(2)} * scale)\n` +
          `Tip: fix "lying down" with correctionRotationDeg X/Z.`;

        setStatus('Ready', true);
      } catch (err) {
        console.error(err);
        setStatus(`Failed: ${err?.message || err}`, false);
      }
    }

    function schedulePreview() {
      if (reloadTimer) clearTimeout(reloadTimer);
      reloadTimer = setTimeout(() => {
        void loadAndPreview();
      }, 80);
    }

    async function reloadMetaForSelectedModel() {
      const modelPath = getSelectedModelPath();
      if (!modelPath) return;

      setStatus('Loading meta.json…');
      const assetType = getAssetType();
      setAssetUiMode(assetType);

      if (assetType === 'weapon') {
        weaponMetaFile = await fetchWeaponMetaFile();
        const entry = weaponMetaFile?.weapons?.[modelPath] || {};
        baseMeta = entry || {};
        lastMetaUrl = '/models/weapon/meta.json';
        setMetaHint(modelPath, entry && Object.keys(entry).length > 0 ? lastMetaUrl : null);
        applyWeaponMetaToUI(baseMeta);
        updateJsonOutput();
        schedulePreview();
        return;
      }

      const { url, json } = await fetchExistingEnemyMeta(modelPath);
      baseMeta = json || {};
      lastMetaUrl = url;
      setMetaHint(modelPath, url && json ? url : null);
      applyEnemyMetaToUI(baseMeta);
      updateJsonOutput();
      schedulePreview();
    }

    function populateMonsterTypes() {
      const keys = Object.keys(MonsterTypes);
      for (const key of keys) {
        const opt = document.createElement('option');
        opt.value = key;
        opt.textContent = `${key} (${MonsterTypes[key]?.name || 'Unnamed'})`;
        ui.typeSelect.appendChild(opt);
      }
      ui.typeSelect.value = 'HUNTER';
    }

    function populateModelList(models) {
      ui.modelSelect.innerHTML = '';
      const list = [...models];
      list.sort((a, b) => a.localeCompare(b));
      for (const path of list) {
        const opt = document.createElement('option');
        opt.value = path;
        opt.textContent = path;
        ui.modelSelect.appendChild(opt);
      }
      ui.modelSelect.value = list[0] || '';
    }

    function hookInputs() {
      ui.assetSelect.addEventListener('change', async () => {
        try {
          baseMeta = {};
          lastMetaUrl = null;
          weaponMetaFile = null;
          setMetaHint(null, null);
          setAssetUiMode(getAssetType());
          setStatus('Loading manifest…');
          const models = await fetchManifest(getAssetType());
          populateModelList(models);
          await reloadMetaForSelectedModel();
        } catch (err) {
          console.error(err);
          setStatus(`Manifest load failed: ${err?.message || err}`, false);
        }
      });

      ui.saveBtn.addEventListener('click', () => {
        void saveMetaForSelectedModel();
      });

      const weaponGizmoMove = document.getElementById('weaponGizmoMove');
      const weaponGizmoRotate = document.getElementById('weaponGizmoRotate');
      const weaponGizmoOff = document.getElementById('weaponGizmoOff');
      const weaponReset = document.getElementById('weaponReset');
      const setGizmoMode = (mode) => {
        if (!transformControls) return;
        transformControls.setMode(mode);
      };
      if (weaponGizmoMove) weaponGizmoMove.addEventListener('click', () => setGizmoMode('translate'));
      if (weaponGizmoRotate) weaponGizmoRotate.addEventListener('click', () => setGizmoMode('rotate'));
      if (weaponGizmoOff) weaponGizmoOff.addEventListener('click', () => {
        if (!transformControls) return;
        transformControls.detach();
        transformControls.visible = false;
      });
      if (weaponReset) weaponReset.addEventListener('click', () => {
        if (getAssetType() !== 'weapon') return;
        ui.wOffX.value = '0';
        ui.wOffY.value = '0';
        ui.wOffZ.value = '0';
        ui.wRotX.value = '0';
        ui.wRotY.value = '0';
        ui.wRotZ.value = '0';
        ui.wScale.value = '1';
        ui.wScaleNum.value = '1';
        updateSliderDisplays();
        updateJsonOutput();
        scheduleAutoSave();
        schedulePreview();
      });

      ui.scaleMul.addEventListener('input', () => {
        syncRangeToNumber(ui.scaleMul, ui.scaleMulNum);
        updateJsonOutput();
        scheduleAutoSave();
        schedulePreview();
      });
      ui.scaleMulNum.addEventListener('input', () => {
        syncNumberToRange(ui.scaleMulNum, ui.scaleMul);
        updateJsonOutput();
        scheduleAutoSave();
        schedulePreview();
      });

      ui.groundOffset.addEventListener('input', () => {
        syncRangeToNumber(ui.groundOffset, ui.groundOffsetNum);
        updateJsonOutput();
        scheduleAutoSave();
        schedulePreview();
      });
      ui.groundOffsetNum.addEventListener('input', () => {
        syncNumberToRange(ui.groundOffsetNum, ui.groundOffset);
        updateJsonOutput();
        scheduleAutoSave();
        schedulePreview();
      });

      for (const el of [ui.rotX, ui.rotY, ui.rotZ]) {
        el.addEventListener('input', () => {
          updateJsonOutput();
          scheduleAutoSave();
          schedulePreview();
        });
      }

      for (const el of [ui.wOffX, ui.wOffY, ui.wOffZ, ui.wRotX, ui.wRotY, ui.wRotZ]) {
        el.addEventListener('input', () => {
          updateJsonOutput();
          if (transformControls?.object) applyWeaponUiToObject(transformControls.object);
          scheduleAutoSave();
          schedulePreview();
        });
      }

      ui.wScale.addEventListener('input', () => {
        syncRangeToNumber(ui.wScale, ui.wScaleNum);
        updateJsonOutput();
        if (transformControls?.object) applyWeaponUiToObject(transformControls.object);
        scheduleAutoSave();
        schedulePreview();
      });
      ui.wScaleNum.addEventListener('input', () => {
        syncNumberToRange(ui.wScaleNum, ui.wScale);
        updateJsonOutput();
        if (transformControls?.object) applyWeaponUiToObject(transformControls.object);
        scheduleAutoSave();
        schedulePreview();
      });

      ui.modelSelect.addEventListener('change', () => {
        baseMeta = {};
        lastMetaUrl = null;
        setMetaHint(getSelectedModelPath(), null);
        void reloadMetaForSelectedModel();
      });

      ui.typeSelect.addEventListener('change', () => {
        schedulePreview();
      });

      ui.reloadMetaBtn.addEventListener('click', () => {
        void reloadMetaForSelectedModel();
      });

      ui.copyBtn.addEventListener('click', async () => {
        try {
          const text = getAssetType() === 'weapon' ? ui.jsonOutWeapon.value : ui.jsonOut.value;
          await navigator.clipboard.writeText(text);
          setStatus('Copied', true);
        } catch (err) {
          void err;
          setStatus('Copy failed (clipboard blocked)', false);
        }
      });
    }

    function resize() {
      const w = ui.canvas.clientWidth;
      const h = ui.canvas.clientHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / Math.max(1, h);
      camera.updateProjectionMatrix();
    }

    window.addEventListener('resize', resize);

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      if (currentHelper) currentHelper.update();
      renderer.render(scene, camera);
    }

    async function init() {
      populateMonsterTypes();
      hookInputs();
      updateSliderDisplays();

      try {
        setAssetUiMode(getAssetType());
        const models = await fetchManifest(getAssetType());
        populateModelList(models);
        await reloadMetaForSelectedModel();
        resize();
        animate();
      } catch (err) {
        console.error(err);
        setStatus(`Manifest load failed: ${err?.message || err}`, false);
      }
    }

    void init();
  </script>
</body>
</html>
