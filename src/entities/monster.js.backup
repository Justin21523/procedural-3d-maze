/**
 * Monster entity class
 * Handles individual monster behavior, movement, and AI
 */

import * as THREE from 'three';
import { CONFIG } from '../core/config.js';

export class Monster {
  /**
   * Create a monster
   * @param {THREE.Group} model - 3D model
   * @param {Object} spawnPosition - Grid position {x, y}
   * @param {WorldState} worldState - Reference to world state
   */
  constructor(model, spawnPosition, worldState) {
    this.model = model;
    this.worldState = worldState;

    // Grid position
    this.gridX = spawnPosition.x;
    this.gridY = spawnPosition.y;

    // Set model scale (GLB models are often too large)
    this.model.scale.set(0.8, 0.8, 0.8);

    // Calculate proper ground level based on model bounding box
    const modelHeight = this.calculateModelHeight();
    const groundOffset = modelHeight / 2;

    console.log(`ðŸ¦Š Monster model height: ${modelHeight.toFixed(2)}, ground offset: ${groundOffset.toFixed(2)}`);

    // World position (place on ground level)
    this.position = new THREE.Vector3(
      spawnPosition.x * CONFIG.TILE_SIZE,
      groundOffset, // Dynamic based on model height
      spawnPosition.y * CONFIG.TILE_SIZE
    );

    // Set model position
    this.model.position.copy(this.position);

    // Ensure all meshes cast and receive shadows
    this.model.traverse((child) => {
      if (child.isMesh) {
        child.castShadow = true;
        child.receiveShadow = true;
      }
    });

    // Movement properties
    this.velocity = new THREE.Vector3();
    this.speed = CONFIG.MONSTER_SPEED;
    this.rotationSpeed = 3; // radians per second

    // AI state
    this.state = 'PATROL'; // PATROL, CHASE, IDLE
    this.patrolPoints = [];
    this.currentPatrolIndex = 0;
    this.chaseTarget = null;

    // Vision
    this.visionRange = CONFIG.MONSTER_VISION_RANGE;
    this.visionFOV = CONFIG.MONSTER_FOV;

    // Animation
    this.mixer = null;
    this.animations = {};
    this.currentAnimation = null;

    // Generate initial patrol path
    this.generatePatrolPath();

    console.log(`ðŸ‘¹ Monster spawned at grid (${this.gridX}, ${this.gridY})`);
  }

  /**
   * Setup animations if available
   * @param {Array} animations - Array of THREE.AnimationClip
   */
  setupAnimations(animations) {
    if (!animations || animations.length === 0) return;

    this.mixer = new THREE.AnimationMixer(this.model);

    animations.forEach(clip => {
      const action = this.mixer.clipAction(clip);
      this.animations[clip.name] = action;
      console.log(`ðŸŽ¬ Animation loaded: ${clip.name}`);
    });

    // Play idle or walk animation by default
    if (this.animations['Idle'] || this.animations['idle']) {
      this.playAnimation('Idle') || this.playAnimation('idle');
    } else if (this.animations['Walk'] || this.animations['walk']) {
      this.playAnimation('Walk') || this.playAnimation('walk');
    }
  }

  /**
   * Play an animation
   * @param {string} name - Animation name
   */
  playAnimation(name) {
    if (!this.animations[name]) return false;

    if (this.currentAnimation) {
      this.currentAnimation.fadeOut(0.2);
    }

    this.currentAnimation = this.animations[name];
    this.currentAnimation.reset().fadeIn(0.2).play();
    return true;
  }

  /**
   * Generate a random patrol path
   */
  generatePatrolPath() {
    this.patrolPoints = [];
    const numPoints = Math.floor(Math.random() * 3) + 3; // 3-5 points

    for (let i = 0; i < numPoints; i++) {
      const point = this.worldState.findRandomWalkableTile();
      this.patrolPoints.push(point);
    }

    console.log(`ðŸš¶ Generated patrol path with ${numPoints} points`);
  }

  /**
   * Update monster AI and movement
   * @param {number} deltaTime - Time since last frame
   * @param {THREE.Vector3} playerPosition - Player position
   */
  update(deltaTime, playerPosition) {
    // Update animation mixer
    if (this.mixer) {
      this.mixer.update(deltaTime);
    }

    // Update AI state
    this.updateAI(playerPosition);

    // Update movement based on state
    switch (this.state) {
      case 'PATROL':
        this.updatePatrol(deltaTime);
        break;
      case 'CHASE':
        this.updateChase(deltaTime, playerPosition);
        break;
      case 'IDLE':
        // Do nothing
        break;
    }

    // Update grid position
    this.gridX = Math.floor(this.position.x / CONFIG.TILE_SIZE);
    this.gridY = Math.floor(this.position.z / CONFIG.TILE_SIZE);
  }

  /**
   * Update AI decision making
   * @param {THREE.Vector3} playerPosition - Player position
   */
  updateAI(playerPosition) {
    const canSeePlayer = this.canSeePlayer(playerPosition);

    if (canSeePlayer && this.state !== 'CHASE') {
      console.log('ðŸ‘ï¸ Monster spotted player!');
      this.state = 'CHASE';
      this.chaseTarget = playerPosition.clone();

      // Play chase animation if available
      if (!this.playAnimation('Run') && !this.playAnimation('run')) {
        this.playAnimation('Walk') || this.playAnimation('walk');
      }
    } else if (!canSeePlayer && this.state === 'CHASE') {
      console.log('â“ Monster lost sight of player');
      this.state = 'PATROL';

      // Play patrol animation
      this.playAnimation('Walk') || this.playAnimation('walk');
    }
  }

  /**
   * Check if monster can see the player
   * @param {THREE.Vector3} playerPosition - Player position
   * @returns {boolean} True if player is visible
   */
  canSeePlayer(playerPosition) {
    const distance = this.position.distanceTo(playerPosition);

    // Too far away
    if (distance > this.visionRange) return false;

    // Calculate direction to player
    const directionToPlayer = new THREE.Vector3()
      .subVectors(playerPosition, this.position)
      .normalize();

    // Get monster's forward direction
    const forward = new THREE.Vector3(0, 0, -1)
      .applyQuaternion(this.model.quaternion);

    // Calculate angle between forward and player direction
    const angle = forward.angleTo(directionToPlayer);

    // Check if within FOV
    return angle < this.visionFOV / 2;
  }

  /**
   * Update patrol behavior
   * @param {number} deltaTime - Time since last frame
   */
  updatePatrol(deltaTime) {
    if (this.patrolPoints.length === 0) {
      this.generatePatrolPath();
      return;
    }

    const targetPoint = this.patrolPoints[this.currentPatrolIndex];
    const targetWorld = new THREE.Vector3(
      targetPoint.x * CONFIG.TILE_SIZE,
      this.position.y, // Keep at current ground level
      targetPoint.y * CONFIG.TILE_SIZE
    );

    // Move towards patrol point
    this.moveTowards(targetWorld, deltaTime);

    // Check if reached patrol point
    const distance = this.position.distanceTo(targetWorld);
    if (distance < 0.5) {
      this.currentPatrolIndex = (this.currentPatrolIndex + 1) % this.patrolPoints.length;
    }
  }

  /**
   * Update chase behavior
   * @param {number} deltaTime - Time since last frame
   * @param {THREE.Vector3} playerPosition - Player position
   */
  updateChase(deltaTime, playerPosition) {
    this.chaseTarget = playerPosition.clone();
    this.moveTowards(this.chaseTarget, deltaTime);
  }

  /**
   * Move towards a target position
   * @param {THREE.Vector3} target - Target position
   * @param {number} deltaTime - Time since last frame
   */
  moveTowards(target, deltaTime) {
    // Calculate direction (only XZ plane, ignore Y)
    const direction = new THREE.Vector3(
      target.x - this.position.x,
      0,
      target.z - this.position.z
    ).normalize();

    // Calculate desired velocity (only XZ movement)
    const desiredVelocity = direction.multiplyScalar(this.speed);

    // Update velocity (smooth movement)
    this.velocity.lerp(desiredVelocity, 0.1);

    // Calculate new position
    const newPosition = this.position.clone().add(
      this.velocity.clone().multiplyScalar(deltaTime)
    );

    // Keep Y at current ground level (don't change height during movement)
    newPosition.y = this.position.y;

    // Check collision with walls
    const newGridX = Math.floor(newPosition.x / CONFIG.TILE_SIZE);
    const newGridZ = Math.floor(newPosition.z / CONFIG.TILE_SIZE);

    if (this.worldState.isWalkable(newGridX, newGridZ)) {
      this.position.copy(newPosition);
      this.model.position.copy(this.position);
    }

    // Rotate to face movement direction
    if (this.velocity.lengthSq() > 0.01) {
      const targetRotation = Math.atan2(this.velocity.x, this.velocity.z);
      const currentRotation = this.model.rotation.y;

      // Smooth rotation
      let deltaRotation = targetRotation - currentRotation;

      // Normalize to -PI to PI
      while (deltaRotation > Math.PI) deltaRotation -= Math.PI * 2;
      while (deltaRotation < -Math.PI) deltaRotation += Math.PI * 2;

      this.model.rotation.y += deltaRotation * this.rotationSpeed * deltaTime;
    }
  }

  /**
   * Get monster's current grid position
   * @returns {Object} Grid position {x, y}
   */
  getGridPosition() {
    return { x: this.gridX, y: this.gridY };
  }

  /**
   * Get monster's world position
   * @returns {THREE.Vector3} World position
   */
  getWorldPosition() {
    return this.position.clone();
  }

  /**
   * Get the 3D model
   * @returns {THREE.Group} The model
   */
  getModel() {
    return this.model;
  }

  /**
   * Calculate model height from bounding box
   * @returns {number} Model height in world units
   */
  calculateModelHeight() {
    // Force update to ensure accurate bounding box
    this.model.updateMatrixWorld(true);

    // Calculate bounding box
    const bbox = new THREE.Box3().setFromObject(this.model);
    const height = bbox.max.y - bbox.min.y;

    // Return calculated height or fallback
    if (height > 0 && height < 10) {
      return height;
    }

    // Fallback to default height if calculation seems wrong
    console.warn('âš ï¸ Invalid model height detected, using fallback');
    return 1.8;
  }
}
